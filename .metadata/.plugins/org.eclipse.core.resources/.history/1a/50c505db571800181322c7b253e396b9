package daa38.Statistics.Auxiliary;

import java.io.IOException;
import java.lang.management.GarbageCollectorMXBean;
import java.lang.management.MemoryUsage;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.management.Notification;
import javax.management.NotificationEmitter;
import javax.management.NotificationListener;
import javax.management.openmbean.CompositeData;

import com.sun.management.GarbageCollectionNotificationInfo;

import daa38.CSP.Auxiliary.UnreasonablyLongTimeException;
import daa38.CSP.LookBack.LookBack;
import daa38.CSP.Main.Solver;
import daa38.CSP.ValueSelection.ValueSelection;
import daa38.CSP.VariableOrdering.VariableOrdering;

public class SingleMemoryGatherer {

	
	//Format of args:
	//args[0] - input file path. File content must be CSP format.
	//args[1] - output file path.
	//args[2] - which Variable Ordering to use.
	//			possible values are:
	//			- 1 = MostConstrainedVariableOrdering
	//			- 2 = LeastConstrainedVariableOrdering
	//			- anything else = RandomVariableOrdering
	//args[3] - which Value Selection to use
	//			possible values are:
	//			- 1 = ForwardChecking
	//			- 2 = FullLookAhead
	//			- 3 = ArcConsistency
	//			- 4 = PartialLookAhead
	//			- anything else = ConsistentAssignmentValueSelection
	//args[4] - which LookBack to use
	//			possible values are:
	//			- 1 = GaschnigsBackjumping
	//			- 2 = GraphBasedBackjumping
	//			- anything else = Backtrack
	public static void main(String[] args) throws IOException, UnreasonablyLongTimeException {
		installGCMonitoring();
		
		String lInPath = args[0];
		String lOutPath = args[1];
		int lOrder = args[2].charAt(0) - '0';
		int lSelect = args[3].charAt(0) - '0';
		int lBack = args[4].charAt(0) - '0';
		
		Solver lS = new Solver();
		VariableOrdering lVO = InputProcessing.intToVO(lOrder, lS);
		ValueSelection lVS = InputProcessing.intToVS(lSelect, lS);
		LookBack lLB = InputProcessing.intToLB(lBack, lS);
		
		lS.solve(lInPath, lOutPath, lVO, lVS, lLB);
		
		
	}
	
	//This method was adapted from here: http://www.fasterj.com/articles/gcnotifs.shtml
	public static void installGCMonitoring(){
		
		
	    //get all the GarbageCollectorMXBeans - there's one for each heap generation
	    //so probably two - the old generation and young generation
	    List<GarbageCollectorMXBean> gcbeans = java.lang.management.ManagementFactory.getGarbageCollectorMXBeans();
	    
	    //Install a notification handler for each bean
	    for (GarbageCollectorMXBean gcbean : gcbeans) {
	      System.out.println(gcbean);
	      
	      NotificationEmitter emitter = (NotificationEmitter) gcbean;
	      
	      //use an anonymously generated listener for this example
	      // - proper code should really use a named class
	      NotificationListener listener = new NotificationListener() {
	        //keep a count of the total time spent in GCs
	        long totalGcDuration = 0;

	        //implement the notifier callback handler
	        @Override
	        public void handleNotification(Notification notification, Object handback) {
	          //we only handle GARBAGE_COLLECTION_NOTIFICATION notifications here
	          if (notification.getType().equals(GarbageCollectionNotificationInfo.GARBAGE_COLLECTION_NOTIFICATION)) {
	            
	        	//get the information associated with this notification
	            GarbageCollectionNotificationInfo info = GarbageCollectionNotificationInfo.from((CompositeData) notification.getUserData());
	            
	            long lBytesUsedBefore = 0;
	            for (MemoryUsage lMU : info.getGcInfo().getMemoryUsageBeforeGc().values())
	            {
	            	lBytesUsedBefore += lMU.getUsed();
	            }
	            
	            long lBytesUsedAfter = 0;
	            for (MemoryUsage lMU : info.getGcInfo().getMemoryUsageAfterGc().values())
	            {
	            	lBytesUsedAfter += lMU.getUsed();
	            }
	            
	            System.out.println("Custom: "+lBytesUsedBefore+" bytes used before; "+lBytesUsedAfter+" bytes used after");
	            
	            
	          }
	        }
	      };

	      //Add the listener
	      emitter.addNotificationListener(listener, null, null);
	    }
	  }
}
