package daa38.CSP.ValueSelection;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;

import daa38.CSP.Auxiliary.StepFrame;
import daa38.CSP.Auxiliary.Variable;
import daa38.CSP.Auxiliary.VariablesRestrictions;

public class ForwardChecking extends ConsistentAssignmentValueSelection {

	@Override
	public void select(StepFrame pSF) {
		Variable lNowVar = pSF.mVar;
		
		Map<Integer, VariablesRestrictions> lAllVR = super.createVariablesRestrictions(lNowVar);
		
		for (Entry<Integer, VariablesRestrictions> lEntryAllVR : lAllVR.entrySet())
		{
			Integer lInt = lEntryAllVR.getKey();
			VariablesRestrictions lOneVR = lEntryAllVR.getValue();
			Map<Variable, Collection<Integer> > lVarToRes = lOneVR.getAllRestrictions();
			
			boolean lFoundEmptyDomain = false;
			for (Entry<Variable, Collection<Integer> > lEntryVarToRes : lVarToRes.entrySet())
			{
				if (lEntryVarToRes.getKey().mDomain.size() == lEntryVarToRes.getValue().size())
				{
					lFoundEmptyDomain = true;
					break;
				}
			}
			
			if (!lFoundEmptyDomain)
			{
				pSF.mValsToGo.add(lEntryAllVR.getKey());
				pSF.mRes.add(lEntryAllVR.getValue());
			}
			
		}
		
		pSF.mNowValIndex=0;

	}

}
