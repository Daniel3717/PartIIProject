package daa38.CSP.LookBack;

import java.util.ArrayList;
import java.util.Stack;

import daa38.CSP.Auxiliary.StepFrame;
import daa38.CSP.Auxiliary.Variable;
import daa38.CSP.Auxiliary.VariablesRestrictions;

public class GaschnigsBackjumping implements LookBack {

	@Override
	public void process(Stack<StepFrame> pStack) {
		
		StepFrame lTopFrame = pStack.peek();
		Variable lVarEnd = lTopFrame.mVarsToGo.get(lTopFrame.mNowVarIndex);
		
		if (lVarEnd.mDomain.size()==0) //so, if it is a leaf dead-end
		{
			do
			{
				lTopFrame = pStack.pop();
				
				lTopFrame.mVarsToGo.get(lTopFrame.mNowVarIndex).mValue = -1;
				lTopFrame.mRes.get(lTopFrame.mNowValIndex).liftRestrictions();
			}
			while (lTopFrame.mRes.get(lTopFrame.mNowValIndex).getVarRestrictions(lVarEnd)==null);
			
			lTopFrame.mNowValIndex++;
			pStack.push(lTopFrame);
		}
		else //if it is an internal dead-end, we just go back one
		{
			
		}

	}

}
